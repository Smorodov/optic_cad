/*

      This file is part of the Goptical Core library.

      The Goptical library is free software; you can redistribute it
      and/or modify it under the terms of the GNU General Public
      License as published by the Free Software Foundation; either
      version 3 of the License, or (at your option) any later version.

      The Goptical library is distributed in the hope that it will be
      useful, but WITHOUT ANY WARRANTY; without even the implied
      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
      See the GNU General Public License for more details.

      You should have received a copy of the GNU General Public
      License along with the Goptical library; if not, write to the
      Free Software Foundation, Inc., 59 Temple Place, Suite 330,
      Boston, MA 02111-1307 USA

      Copyright (C) 2010-2011 Free Software Foundation, Inc
      Author: Alexandre Becoulet

*/

#ifndef GOPTICAL_TRACEDRAY_HH_
#define GOPTICAL_TRACEDRAY_HH_

#include <limits>

#include "goptical/core/common.hpp"

#include "goptical/core/light/ray.hpp"
#include "goptical/core/math/vector.hpp"

#include "goptical/core/sys/element.hpp"
#include "goptical/core/sys/image.hpp"

#include "goptical/core/math/transform.hpp"

namespace goptical
{

	namespace trace
	{

		/**
		   @short Propagated light ray class
		   @header <goptical/core/trace/Ray
		   @module {Core}

		   This class is used to describe a @ref light::Ray with all
		   tracing and propagation informations attached.
		 */
		class Ray : public light::Ray
		{
			public:
				/** Create a propagated light ray */
				inline Ray ();

				/** Create a propagated light ray */
				inline Ray (const light::Ray &r);

				GOPTICAL_ACCESSORS (const sys::Element *, creator,
				                    "element which generated this ray.");

				GOPTICAL_ACCESSORS (const material::Base *, material,
				                    "material ray is propagated in.");

				GOPTICAL_ACCESSORS (double, intercept_intensity,
				                    "ray intensity at interception point.");

				GOPTICAL_ACCESSORS (double, len, "light ray length.");

				/** Define a new child generated ray */
				inline void add_generated (trace::Ray *r);

				/** Set light ray interception point and element */
				inline void set_intercept (const sys::Element &e,
				                           const math::Vector3 &point);
				/** Get light ray interception point */
				inline const math::Vector3 &get_intercept_point () const;
				/** Get light ray interception element */
				inline sys::Element &get_intercept_element () const;

				/** Get ray which generated this one */
				inline Ray *get_parent () const;
				/** Get first ray generated from this one */
				inline Ray *get_first_child () const;
				/** Get next sibling ray generated by same parent */
				inline Ray *get_next_child () const;

				/** Return true if ray is not intercepted */
				inline bool is_lost () const;

				/** Get global position */
				inline math::Vector3 get_position () const;
				/** Get global direction */
				inline math::Vector3 get_direction () const;

				/** Get position relative to given element */
				inline math::Vector3 get_position (const sys::Element &e) const;
				/** Get direction relative to given element */
				inline math::Vector3 get_direction (const sys::Element &e) const;

			private:
				Ray (const Ray &);
				const Ray &operator= (const Ray &r);

				math::Vector3 _point; // ray intersection point (intersect surface local)
				double _intercept_intensity;     // intersection point intensity
				double _len;                     // ray length
				const sys::Element *_creator;    // element which generated this ray
				const material::Base *_material; // material
				sys::Element *_i_element;        // intersect element
				Ray *_parent;                    // ray which generated this one
				Ray *_child;                     // pointer to generated ray
				Ray *_next;                      // pointer to sibling generated ray
				bool _lost;                      // does the ray intersect with an element ?
		};
		Ray::Ray ()
			: light::Ray (), _len (DBL_MAX), _creator (0),
			  _parent (0), _child (0), _lost (true)
		{
		}

		Ray::Ray (const light::Ray &r)
			: light::Ray (r), _len (DBL_MAX), _creator (0),
			  _parent (0), _child (0), _lost (true)
		{
		}

		void
		Ray::add_generated (Ray *r)
		{
			assert (!r->_parent);
			r->_parent = this;
			r->_next = _child;
			_child = r;
		}

		void
		Ray::set_intercept (const sys::Element &e, const math::Vector3 &point)
		{
			_i_element = (sys::Element *)&e;
			_point = point;
			_lost = false;
		}

		Ray *
		Ray::get_parent () const
		{
			return _parent;
		}

		Ray *
		Ray::get_next_child () const
		{
			return _next;
		}

		Ray *
		Ray::get_first_child () const
		{
			return _child;
		}

		const math::Vector3 &
		Ray::get_intercept_point () const
		{
			return _point;
		}

		bool
		Ray::is_lost () const
		{
			return _lost;
		}

		sys::Element &
		Ray::get_intercept_element () const
		{
			return *_i_element;
		}

		math::Vector3
		Ray::get_position (const sys::Element &e) const
		{
			return _creator->get_transform_to (e).transform (origin ());
		}

		math::Vector3
		Ray::get_direction (const sys::Element &e) const
		{
			return _creator->get_transform_to (e).transform_linear (direction ());
		}

		math::Vector3
		Ray::get_position () const
		{
			return _creator->get_global_transform ().transform (origin ());
		}

		math::Vector3
		Ray::get_direction () const
		{
			return _creator->get_global_transform ().transform_linear (direction ());
		}

	}

}

#endif
