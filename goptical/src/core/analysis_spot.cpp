/*

      This file is part of the <goptical/core Core library.

      The <goptical/core library is free software; you can redistribute it
      and/or modify it under the terms of the GNU General Public
      License as published by the Free Software Foundation; either
      version 3 of the License, or (at your option) any later version.

      The <goptical/core library is distributed in the hope that it will be
      useful, but WITHOUT ANY WARRANTY; without even the implied
      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
      See the GNU General Public License for more details.

      You should have received a copy of the GNU General Public
      License along with the <goptical/core library; if not, write to the
      Free Software Foundation, Inc., 59 Temple Place, Suite 330,
      Boston, MA 02111-1307 USA

      Copyright (C) 2010-2011 Free Software Foundation, Inc
      Author: Alexandre Becoulet

*/

#include <goptical/core/analysis/spot.hpp>
#include <goptical/core/sys/image.hpp>

#include <goptical/core/trace/distribution.hpp>
#include <goptical/core/trace/ray.hpp>
#include <goptical/core/trace/result.hpp>
#include <goptical/core/trace/tracer.hpp>

#include <goptical/core/io/renderer_axes.hpp>
#include <goptical/core/io/renderer_viewport.hpp>

#include <goptical/core/data/plot.hpp>
#include <goptical/core/data/plotdata.hpp>
#include <goptical/core/data/sample_set.hpp>

#include <goptical/core/light/spectral_line.hpp>

namespace goptical
{

	namespace analysis
	{

		Spot::Spot (std::shared_ptr<sys::System> &system)
			: PointImage (system), _processed_analysis (false)
		{
			_axes.set_show_axes (false, io::RendererAxes::XY);
			_axes.set_label ("Saggital distance", io::RendererAxes::X);
			_axes.set_label ("Tangential distance", io::RendererAxes::Y);
			_axes.set_unit ("m", true, true, -3, io::RendererAxes::XY);
		}

		void
		Spot::process_trace ()
		{
			if (_processed_trace)
			{
				return;
			}
			trace ();
			_centroid = _tracer.get_trace_result ().get_intercepted_centroid (*_image);
		}

		void
		Spot::process_analysis ()
		{
			if (_processed_analysis)
			{
				return;
			}
			process_trace ();
			double mean = 0;      // rms radius
			double max = 0;       // max radius
			double intensity = 0; // total intensity
for (auto &i : *_intercepts)
			{
				double dist = (i->get_intercept_point () - _centroid).len ();
				if (max < dist)
				{
					max = dist;
				}
				mean += math::square (dist);
				intensity += i->get_intensity ();
			}
			_useful_radius = _max_radius = max;
			_rms_radius = sqrt (mean / _intercepts->size ());
			_tot_intensity = intensity;
			_processed_analysis = true;
		}

		double
		Spot::get_encircled_intensity (double radius)
		{
			process_trace ();
			double intensity = 0;
for (auto &i : *_intercepts)
			{
				if ((i->get_intercept_point () - _centroid).len () <= radius)
				{
					intensity += i->get_intensity ();
				}
			}
			return intensity;
		}

		std::shared_ptr<data::Plot>
		Spot::get_encircled_intensity_plot (int zones)
		{
			trace::Result &result = _tracer.get_trace_result ();
			const trace::rays_queue_t &intercepts = result.get_intercepted (*_image);
			process_analysis ();
			if (intercepts.empty ())
			{
				throw Error ("no ray intercept found for encircled intensity plot");
			}
			typedef std::map<double, std::shared_ptr<data::SampleSet> > data_sets_t;
			data_sets_t data_sets;
			// create plot data for each wavelen
for (auto &w : result.get_ray_wavelen_set ())
			{
				std::shared_ptr<data::SampleSet> s
				    = std::make_shared<data::SampleSet> ();
				s->set_interpolation (data::Linear);
				s->set_metrics (0.0, _useful_radius / (double)zones);
				s->resize (zones + 1);
				data_sets.insert (data_sets_t::value_type (w, s));
			}
			// compute encircled intensity for each radius range
for (auto &i : *_intercepts)
			{
				double dist = (i->get_intercept_point () - _centroid).len ();
				if (dist > _useful_radius)
				{
					continue;
				}
				int n = (unsigned int)((zones - 1) * (dist / _useful_radius));
				assert (n >= 0 && n < zones);
				data_sets[i->get_wavelen ()]->get_y_value (n + 1) += i->get_intensity ();
			}
			// integrate
			std::shared_ptr<data::Plot> plot = std::make_shared<data::Plot> ();
for (auto &d : data_sets)
			{
				for (int i = 1; i < zones; i++)
				{
					d.second->get_y_value (i + 1) += d.second->get_y_value (i);
				}
				data::Plotdata p (d.second);
				//      p.set_label("Encircled ray intensity"); FIXME set wavelen
				p.set_color (light::SpectralLine::get_wavelen_color (d.first));
				p.set_style (data::LinePlot);
				plot->add_plot_data (p);
			}
			plot->set_title ("Spot diagram encircled rays intensity");
			plot->get_axes ().set_label ("Distance from spot centroid",
			                             io::RendererAxes::X);
			plot->get_axes ().set_label ("Encircled intensity", io::RendererAxes::Y);
			plot->get_axes ().set_unit ("m", true, true, -3, io::RendererAxes::X);
			plot->get_axes ().set_unit ("", false, false, 0, io::RendererAxes::Y);
			return plot;
		}

		math::Vector3
		Spot::get_center ()
		{
			process_analysis ();
			return _tracer.get_trace_result ().get_intercepted_center (*_image);
		}

		void
		Spot::draw_spot (io::RendererViewport &renderer)
		{
			process_analysis ();
			trace::Result &result = _tracer.get_trace_result ();
			renderer.draw_intercepts (result, *_image);
		}

		void
		Spot::draw_diagram (io::RendererViewport &renderer, bool centroid_origin)
		{
			process_analysis ();
			trace::Result &result = _tracer.get_trace_result ();
			math::Vector2 center (result.get_intercepted_center (*_image), 0, 1);
			math::Vector2 radius (_useful_radius, _useful_radius);
			renderer.set_window (math::VectorPair2 (center - radius, center + radius));
			_axes.set_position (_centroid);
			_axes.set_origin (centroid_origin ? _centroid : math::vector3_0);
			_axes.set_tics_count (3, io::RendererAxes::XY);
			renderer.draw_axes_2d (_axes);
			renderer.draw_intercepts (result, *_image);
		}

	}
}
